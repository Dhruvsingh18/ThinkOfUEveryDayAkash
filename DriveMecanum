package org.firstinspires.ftc.teamcode.Opmodes;

import android.text.method.Touch;

import com.acmerobotics.dashboard.FtcDashboard;
import com.acmerobotics.dashboard.telemetry.TelemetryPacket;
import com.acmerobotics.roadrunner.Pose2d;
import com.acmerobotics.roadrunner.PoseVelocity2d;
import com.acmerobotics.roadrunner.Vector2d;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.ColorSensor;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DistanceSensor;
import com.qualcomm.robotcore.hardware.NormalizedColorSensor;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.TouchSensor;

import org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;
import org.firstinspires.ftc.teamcode.Autos.SpecAuto;
import org.firstinspires.ftc.teamcode.Drawing;
import org.firstinspires.ftc.teamcode.MecanumDrive;
import org.firstinspires.ftc.teamcode.TankDrive;
import org.firstinspires.ftc.teamcode.tuning.TuningOpModes;

//#Todo: Slides are still pushing down and restricting other movements
@TeleOp(name = "IBeFreshAsHellRockingPrada", group = "TeleOp")

public class LeagueQualDrive extends LinearOpMode {

    private DcMotor frontLeft, backLeft, frontRight, backRight, extension;
    private DcMotor intake, rightVerticalMotor, leftVerticalMotor;
    private Servo extendDepo, tiltDepo, claw, leftHang, rightHang, holdChute, intakeTilt, wristClaw;
    private TouchSensor vertSwitch, hortSwitch;
    private ColorSensor colorChute;

    boolean depoSpecMotor = false;
    boolean depoHang = false;
    boolean depoSwing = false;
    boolean dropStall = false;
    boolean upPos = false;
    boolean slideDown = false;
    boolean transferStall = false;
    boolean TransferSlide = false;
    boolean sampleMotor = false;
    long currentTime = 0;


    double left_drivePower;
    double right_drivePower;
    double back_right_drivePower;
    double back_left_drivePower;

    private double redValue;
    private double greenValue;
    private double blueValue;
    private double alphaValue;
    private double targetValue = 1000;

    boolean rumbled = false;


    @Override
    public void runOpMode() throws InterruptedException {

        intake = hardwareMap.dcMotor.get("intake");
        extendDepo = hardwareMap.servo.get("extendDepo");
        tiltDepo = hardwareMap.servo.get("tiltDepo");
        claw = hardwareMap.servo.get("claw");
        holdChute = hardwareMap.servo.get("holdChute");

        //leftHang = hardwareMap.servo.get("leftHang");
        //rightHang = hardwareMap.servo.get("rightHang");

        intakeTilt = hardwareMap.servo.get("intakeTilt");
        wristClaw = hardwareMap.servo.get("wristClaw");


        rightVerticalMotor = hardwareMap.dcMotor.get("rightVert");
        leftVerticalMotor = hardwareMap.dcMotor.get("leftVert");
        extension = hardwareMap.dcMotor.get("extension");

        vertSwitch = hardwareMap.touchSensor.get("vertSwitch");
        hortSwitch = hardwareMap.touchSensor.get("hortSwitch");

        colorChute = hardwareMap.get(ColorSensor.class, "colorChute");

        frontLeft = hardwareMap.dcMotor.get("frontLeft");
        backLeft = hardwareMap.dcMotor.get("backLeft");
        frontRight = hardwareMap.dcMotor.get("frontRight");
        backRight = hardwareMap.dcMotor.get("backRight");

        backRight.setDirection(DcMotor.Direction.REVERSE);
        frontRight.setDirection(DcMotor.Direction.REVERSE);


        //intakeReset();

        intakeReset();

        holdChute.setPosition(0.41);
        CloseClaw();
        //OpenClaw();

        intakeTilt.setPosition(0.5);
        //resetPos();


        waitForStart();
        while (opModeIsActive()) {
            //robotCentricMovementController();
            //LocalizerController();
            tankMecanumMovementController();


            //Todo: Telemetry of Sensors, Encoders, etc
            getColor();
            colorTelmetry();
            VertTelemetry();
            EncoderTelemetry();

            //Todo: Claw Logic

            double pos = extension.getCurrentPosition() * -1;
            telemetry.addData("Extension Encoder Position", pos);
            telemetry.update();


            //Todo: Transfer Logic
            if (!hortSwitch.isPressed()) {
                OpenClaw();
            }

            /*
            if (hortSwitch.isPressed()) {
                CloseClaw();
            }

             */

            //Pushes Slides Down All the Way or Change it so that slides continously push Down

            /*
            if (vertSwitch.isPressed() && !TransferSlide) {
                currentTime = System.currentTimeMillis();
                TransferSlide = true;

            }

            if (TransferSlide) {

                if (System.currentTimeMillis() - currentTime < 600) {
                    rightVerticalMotor.setPower(-0.7);
                    leftVerticalMotor.setPower(0.7);
                    TransferSlide = false;
                }
            }

             */

            if (hortSwitch.isPressed()) {
                holdChute.setPosition(0.46);//0.58

                telemetry.addData("Transfer:", "Ready");
                telemetry.update();

            } else {
                telemetry.addData("Transfer:", "Not Ready");
                telemetry.update();
                holdChute.setPosition(0.105);//0.13




                //0.5
            }


            //Todo: Intake

            if (gamepad2.a) {
                intake.setPower(-1);
                intakePickPos();
                //intakeDown();

                /*
                if(redValue > blueValue){
                    holdChute.setPosition(0.5);
                    telemetry.addData("Red Detected: ", "Poop Chute");
.                    telemetry.update();
                    sleep(100);
                }

                if(blueValue > redValue){
                    holdChute.setPosition(0.43);
                    telemetry.addData("Blue Detected: ", "Hold");
                    telemetry.update();
                    sleep(100);
                }

                 */
            } else if (gamepad2.b) {
                intake.setPower(1);
                intakeSpit();
            } else {
                intake.setPower(0);

            }

            if (gamepad2.y && !dropStall) {
                depositPos();
                currentTime = System.currentTimeMillis();
                dropStall = true;

            }

            if (gamepad2.x) {
                CloseClaw();
            }

            if (dropStall) {

                if (System.currentTimeMillis() - currentTime > 700) {
                    OpenClaw();
                    dropStall = false;
                }
            }



            //Todo: Verts


            boolean vertUp = gamepad2.right_trigger > 0.3;
            boolean vertDown = gamepad2.left_trigger > 0.3;

            if (vertDown) {
                rightVerticalMotor.setPower(-1);
                leftVerticalMotor.setPower(1);


            } else if (vertUp) {
                rightVerticalMotor.setPower(1);
                leftVerticalMotor.setPower(-1);

            } else {
                rightVerticalMotor.setPower(0.13);
                leftVerticalMotor.setPower(-0.13);//0.13
                //change
            }


            boolean BackwardHort = gamepad2.right_bumper;
            boolean ForwardHort = gamepad2.left_bumper;


            if (ForwardHort) { //actually backwards
                extension.setPower(1);
                //intakeReset();
                backPos();


            } else if (BackwardHort) { //forwards
                extension.setPower(-1);
                intakeReset();
            } else {
                extension.setPower(0); //Todo: Consider pressing it in

            }


            boolean vertSpecPick = gamepad2.dpad_left;
            boolean vertSpecHang = gamepad2.dpad_right;
            boolean vertSampleDepo = gamepad2.dpad_up;
            boolean vertReset = gamepad2.dpad_down;


            //Todo: Specimen Hang & PickUp

            if (vertSpecPick && !slideDown) {

                pickSpecPos();

                slideDown = true;

            } else if (vertSpecHang && !depoHang && !depoSwing && vertSwitch.isPressed()) {

                CloseClaw();

                currentTime = System.currentTimeMillis();
                depoHang = true;
                depoSwing = true;

            } else if (vertSampleDepo /*!sampleMotor*/ && !upPos) {
                CloseClaw();
                //sampleMotor = true;
                currentTime = System.currentTimeMillis();
                upPos = true;

            } else if (vertReset && !slideDown) {
                resetPos();
                OpenClaw();
                slideDown = true;


            }
            if (slideDown && !rumbled) {
                gamepad2.rumble(500);
                gamepad2.rumble(500);
                rumbled = true;
            } else if (!slideDown && rumbled) {
                rumbled = false;
                gamepad2.stopRumble();
            }

            //Todo: Booleans for delays
            if (depoSpecMotor) {

                if (System.currentTimeMillis() - currentTime < 250) {
                    rightVerticalMotor.setPower(-0.7); //reversed
                    leftVerticalMotor.setPower(0.7);
                    telemetry.addData("Vert Sensor:", "Not Pressed");
                    telemetry.update();

                } else if (vertSwitch.isPressed()) {
                    rightVerticalMotor.setPower(0);
                    leftVerticalMotor.setPower(0);
                    telemetry.addData("Vert Sensor:", "Pressed");
                    telemetry.update();

                    depoSpecMotor = false;
                } else {  //limit switch code can be added here - change to else if
                    rightVerticalMotor.setPower(0);
                    leftVerticalMotor.setPower(0);
                    telemetry.addData("Condition:", "Timeout");
                    telemetry.update();

                    depoSpecMotor = false;
                }

            } else if (depoHang) {
                if (System.currentTimeMillis() - currentTime < 350) {
                    rightVerticalMotor.setPower(1);
                    leftVerticalMotor.setPower(-1);
                } else {  //limit switch code can be added here - change to else if
                    rightVerticalMotor.setPower(0);
                    leftVerticalMotor.setPower(0);
                    depoHang = false;
                }

            } else if (depoSwing) {
                if (System.currentTimeMillis() - currentTime > 350) {
                    specPos();

                    depoSwing = false;
                }
            } else if (upPos) {
                if (System.currentTimeMillis() - currentTime > 400) {
                    depoUp();
                    upPos = false;
                }
            } else if (sampleMotor) {
                if (System.currentTimeMillis() - currentTime < 2400) {
                    rightVerticalMotor.setPower(1);
                    leftVerticalMotor.setPower(-1);
                } else {  //limit switch code can be added here - change to else if
                    rightVerticalMotor.setPower(0);
                    leftVerticalMotor.setPower(0);
                    sampleMotor = false;
                }

            } else if (slideDown) {
                if (!vertSwitch.isPressed()) {
                    rightVerticalMotor.setPower(-0.8);
                    leftVerticalMotor.setPower(0.8);
                } else {
                    rightVerticalMotor.setPower(0); //Todo: change to press down
                    leftVerticalMotor.setPower(0);  //Todo: change to press down

                    slideDown = false;
                }
            }


        }
    }

    //Todo: Attachment Methods

    public void intakeDown() {

        intakeTilt.setPosition(0.55);
    }

    public void intakeReset() {

        intakeTilt.setPosition(0.4);
    }

    public void intakePickPos() {

        intakeTilt.setPosition(0.32);//0.61
    }

    public void backPos(){
        intakeTilt.setPosition(0.45);
    }

    public void intakeSpit() {

        intakeTilt.setPosition(0.49);//0.61
    } //0.71


    public void OpenClaw() {

        claw.setPosition(0.6);;//0.42
    }

    public void CloseClaw() {

        claw.setPosition(0.15);
    }

    public void specPos() {
        tiltDepo.setPosition(0.1);//0.07
        wristClaw.setPosition(0.82); //0.8
        extendDepo.setPosition(0.63);//0.645
    }

    public void depoUp() {
        extendDepo.setPosition(0.71);
        tiltDepo.setPosition(0.49);

    }

    public void depositPos() {
        tiltDepo.setPosition(0.7);
        extendDepo.setPosition(0.71);
        //wristClaw.setPosition(0.4);
    }

    public void pickSpecPos() {
        tiltDepo.setPosition(0.825);
        extendDepo.setPosition(0.93);
        wristClaw.setPosition(0.0);
    }

    public void resetPos() {
        tiltDepo.setPosition(0.116);//0.11
        wristClaw.setPosition(0.79); //0.8
        extendDepo.setPosition(0.62);//0.595
    }

    public void getColor() {
        redValue = colorChute.red();
        greenValue = colorChute.green();
        blueValue = colorChute.blue();
        alphaValue = colorChute.alpha();

    }

    public void colorTelmetry() {
        telemetry.addData("red", "%.2f", redValue);
        telemetry.addData("blue", "%.2f", blueValue);
        telemetry.addData("green", "%.2f", greenValue);
        telemetry.addData("alpha", "%.2f", alphaValue);
    }

    public void VertTelemetry() {
        if (vertSwitch.isPressed()) {
            telemetry.addData("Vert Sensor:", "Pressed");
            telemetry.update();
            //sleep(100);

        } else {
            telemetry.addData("Vert Sensor:", "Not Pressed");
            telemetry.update();
        }

    }

    public void EncoderTelemetry() {
        telemetry.addData("leftMot", leftVerticalMotor.getCurrentPosition() * -1);
        telemetry.update();
    }

    private void tankMecanumMovementController() {

        frontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        frontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        if (gamepad1.right_bumper) {
            frontLeft.setPower(1);
            backLeft.setPower(-1);
            frontRight.setPower(-1);
            backRight.setPower(1);
        }
        //Strafe left
        else if (gamepad1.left_bumper) {
            frontLeft.setPower(-1);
            backLeft.setPower(1);
            frontRight.setPower(1);
            backRight.setPower(-1);
        } else {
            //regular tank
            right_drivePower = gamepad1.right_stick_y * -1;
            back_left_drivePower = gamepad1.left_stick_y * -1;
            left_drivePower = gamepad1.left_stick_y * -1;
            back_right_drivePower = gamepad1.right_stick_y * -1;


            frontLeft.setPower(left_drivePower);
            frontRight.setPower(right_drivePower);
            backLeft.setPower(left_drivePower);
            backRight.setPower(right_drivePower);
        }

        if (gamepad1.a) {
            frontLeft.setPower(0.4);
            frontRight.setPower(0.4);
            backLeft.setPower(0.4);
            backRight.setPower(0.4);
        }

        if (gamepad1.b) {
            frontLeft.setPower(-0.4);
            frontRight.setPower(-0.4);
            backLeft.setPower(-0.4);
            backRight.setPower(-0.4);
        }

    }


    //Todo: Robot Centric Controller

    private void robotCentricMovementController() {

        frontLeft.setDirection(DcMotor.Direction.REVERSE);
        backLeft.setDirection(DcMotor.Direction.REVERSE);
        frontRight.setDirection(DcMotor.Direction.FORWARD);
        backRight.setDirection(DcMotor.Direction.FORWARD);

        //set drive motor zero power behavior to brake.
        frontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        frontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        double forwardsInput = gamepad1.left_stick_y; //negative bf
        double sidewaysInput = -gamepad1.left_stick_x;
        double steeringInput = gamepad1.right_stick_x;
        double speed = 1;


        //calculate motor power
        double leftFrontPower = forwardsInput + sidewaysInput + (steeringInput * speed);
        double rightFrontPower = forwardsInput - sidewaysInput - (steeringInput * speed);
        double leftBackPower = forwardsInput - sidewaysInput + (steeringInput * speed);
        double rightBackPower = forwardsInput + sidewaysInput - (steeringInput * speed);

        //clamp max power
        double max = Math.max(Math.abs(leftFrontPower), Math.abs(rightFrontPower));
        max = Math.max(max, Math.abs(leftBackPower));
        max = Math.max(max, Math.abs(rightBackPower));

        if (max > 1.0) {
            leftFrontPower = leftFrontPower / max;
            rightFrontPower = rightFrontPower / max;
            leftBackPower = leftBackPower / max;
            rightBackPower = rightBackPower / max;
        }


        //set motor power
        if (gamepad1.right_bumper) {
            frontLeft.setPower(1);
            backLeft.setPower(-1);
            frontRight.setPower(-1);
            backRight.setPower(1);
        }
        //Strafe left
        else if (gamepad1.left_bumper) {
            frontLeft.setPower(-1);
            backLeft.setPower(1);
            frontRight.setPower(1);
            backRight.setPower(-1);
        } else {
            frontLeft.setPower(leftFrontPower);
            frontRight.setPower(rightFrontPower);
            backLeft.setPower(leftBackPower);
            backRight.setPower(rightBackPower);
        }
    }

    private void LocalizerController() {
        if (TuningOpModes.DRIVE_CLASS.equals(MecanumDrive.class)) {
            MecanumDrive drive = new MecanumDrive(hardwareMap, new Pose2d(0, 0, 0));



            //while (opModeIsActive()) {
                drive.setDrivePowers(new PoseVelocity2d(
                        new Vector2d(
                                -gamepad1.left_stick_y,
                                -gamepad1.left_stick_x
                        ),
                        (-gamepad1.right_stick_x * 0.6)
                ));

                drive.updatePoseEstimate();

                Pose2d pose = drive.localizer.getPose();
                telemetry.addData("x", pose.position.x);
                telemetry.addData("y", pose.position.y);
                telemetry.addData("heading (deg)", Math.toDegrees(pose.heading.toDouble()));
                telemetry.update();

                TelemetryPacket packet = new TelemetryPacket();
                packet.fieldOverlay().setStroke("#3F51B5");
                Drawing.drawRobot(packet.fieldOverlay(), pose);
                FtcDashboard.getInstance().sendTelemetryPacket(packet);
           // }
        } else if (TuningOpModes.DRIVE_CLASS.equals(TankDrive.class)) {
            TankDrive drive = new TankDrive(hardwareMap, new Pose2d(0, 0, 0));

           // while (opModeIsActive()) {
                drive.setDrivePowers(new PoseVelocity2d(
                        new Vector2d(
                                -gamepad1.left_stick_y,
                                0.0
                        ),
                        -gamepad1.right_stick_x
                ));

           // }


        }
    }
}
